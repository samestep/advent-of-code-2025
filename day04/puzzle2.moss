import "../lib.moss" as lib use Grid, Layout, List, Loc;

assume lib::Ctx;

fn count(char: Char): Int {
  if char == '@' { 1 } else { 0 }
}

fn .adjacent[This=Grid]({ row, col }: Loc): Int {
    count(this.get({ row = row - 1, col = col - 1 }))
  + count(this.get({ row = row - 1, col           }))
  + count(this.get({ row = row - 1, col = col + 1 }))
  + count(this.get({ row          , col = col - 1 }))
  + count(this.get({ row          , col = col + 1 }))
  + count(this.get({ row = row + 1, col = col - 1 }))
  + count(this.get({ row = row + 1, col           }))
  + count(this.get({ row = row + 1, col = col + 1 }))
}

fn .removable[This=Grid](loc: Loc): Bool {
  (grid.get(loc) != '@') & (grid.adjacent(loc) < 4)
}

fn .remove[This=Grid](loc: Loc) {
  this.set(loc, '.').unwrap();
}

fn attempt[Layout[Loc]](grid: Grid, inout stack: List[Loc], loc: Loc) {
  if grid.removable(loc) {
    stack.push(loc);
  }
}

fn main![Std]() {
  bind lib::ctx();
  let input = lib::input();
  let grid = input.grid();
  var stack = List[Loc]::new();
  var row = 0;
  while row < grid.height() {
    var col = 0;
    while col < grid.width() {
      attempt(grid, stack, { row, col });
      col += 1;
    }
    row += 1;
  }
  var rolls = 0;
  loop {
    let row, col = match stack.pop() {
      None => break,
      Some(top) => top,
    };
    if grid.get({ row, col }) == '@' {
      grid.remove({ row, col });
      rolls += 1;
      var loc;
      attempt(grid, stack, { row = row - 1, col = col - 1 });
      attempt(grid, stack, { row = row - 1, col           });
      attempt(grid, stack, { row = row - 1, col = col + 1 });
      attempt(grid, stack, { row          , col = col - 1 });
      attempt(grid, stack, { row          , col = col + 1 });
      attempt(grid, stack, { row = row + 1, col = col - 1 });
      attempt(grid, stack, { row = row + 1, col           });
      attempt(grid, stack, { row = row + 1, col = col + 1 });
    }
  }
  lib::println(rolls.to_string());
}
