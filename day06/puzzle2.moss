type I32 = wasm::I32;

struct Grid {
  string: String,
  width: I32,
}

fn Grid.width(): I32 {
  this.width
}

fn Grid.height(): I32 {
  this.string.length / (this.width + 1)
}

fn Grid.get[basic](row: I32, col: I32): I32 {
  this.string.get(row * (this.width() + 1) + col)
}

fn make_grid[basic](string: String): Grid {
  var width = 0;
  while string.get(width) != 10 {
    width = width + 1;
  }
  Grid { string, width }
}

fn main[alloc]() {
  let input = read(args().get(1));
  let grid = make_grid(input);
  var grand_total = wasm::i64_extend_i32_u(0);
  var column = 0;
  while column < grid.width() {
    var end = column;
    var searching = true;
    while searching {
      var found = true;
      var row = 0;
      while row < grid.height() {
        if grid.get(row, end) != 32 {
          found = false;
        }
        row = row + 1;
      }
      if found {
        searching = false;
      } else {
        end = end + 1;
        if end >= grid.width() {
          searching = false;
        }
      }
    }
    let op = grid.get(grid.height() - 1, column);
    if op == 32 {
      wasm::unreachable();
    }
    var answer = wasm::i64_extend_i32_u(0);
    if op == 42 {
      answer = wasm::i64_extend_i32_u(1);
    }
    var col = end - 1;
    while col >= column {
      var n = wasm::i64_extend_i32_u(0);
      row = 0;
      while row < grid.height() - 1 {
        let c = wasm::i64_extend_i32_u(grid.get(row, col));
        if wasm::i64_ne(c, wasm::i64_extend_i32_u(32)) {
          let d = wasm::i64_sub(c, wasm::i64_extend_i32_u(48));
          n = wasm::i64_mul(n, wasm::i64_extend_i32_u(10));
          n = wasm::i64_add(n, d);
        }
        row = row + 1;
      }
      if op == 42 {
        answer = wasm::i64_mul(answer, n);
      } else if op == 43 {
        answer = wasm::i64_add(answer, n);
      } else {
        wasm::unreachable();
      }
      col = col - 1;
    }
    grand_total = wasm::i64_add(grand_total, answer);
    column = end + 1;
  }
  println(uint64_to_string(grand_total));
}
